{"ast":null,"code":"\"use strict\"; // Copyright 2014-2016, Google, Inc.\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst fs = require(\"fs\");\n\nconst google_auth_library_1 = require(\"google-auth-library\");\n\nconst pify = require(\"pify\");\n\nconst url = require(\"url\");\n\nconst util = require(\"util\");\n\nconst apirequest_1 = require(\"./apirequest\");\n\nconst endpoint_1 = require(\"./endpoint\");\n\nconst fsp = pify(fs);\n\nclass Discovery {\n  /**\n   * Discovery for discovering API endpoints\n   *\n   * @param options Options for discovery\n   */\n  constructor(options) {\n    this.transporter = new google_auth_library_1.DefaultTransporter();\n    this.options = options || {};\n  }\n  /**\n   * Generate and Endpoint from an endpoint schema object.\n   *\n   * @param schema The schema from which to generate the Endpoint.\n   * @return A function that creates an endpoint.\n   */\n\n\n  makeEndpoint(schema) {\n    return options => {\n      const ep = new endpoint_1.Endpoint(options);\n      ep.applySchema(ep, schema, schema, ep);\n      return ep;\n    };\n  }\n  /**\n   * Log output of generator. Works just like console.log\n   */\n\n\n  log(...args) {\n    if (this.options && this.options.debug) {\n      console.log(...args);\n    }\n  }\n  /**\n   * Generate all APIs and return as in-memory object.\n   * @param discoveryUrl\n   */\n\n\n  discoverAllAPIs(discoveryUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const headers = this.options.includePrivate ? {} : {\n        'X-User-Ip': '0.0.0.0'\n      };\n      const res = yield this.transporter.request({\n        url: discoveryUrl,\n        headers\n      });\n      const items = res.data.items;\n      const apis = yield Promise.all(items.map(api => __awaiter(this, void 0, void 0, function* () {\n        const endpointCreator = yield this.discoverAPI(api.discoveryRestUrl);\n        return {\n          api,\n          endpointCreator\n        };\n      })));\n      const versionIndex = {}; // tslint:disable-next-line no-any\n\n      const apisIndex = {};\n\n      for (const set of apis) {\n        if (!apisIndex[set.api.name]) {\n          versionIndex[set.api.name] = {};\n\n          apisIndex[set.api.name] = options => {\n            const type = typeof options;\n            let version;\n\n            if (type === 'string') {\n              version = options;\n              options = {};\n            } else if (type === 'object') {\n              version = options.version;\n              delete options.version;\n            } else {\n              throw new Error('Argument error: Accepts only string or object');\n            }\n\n            try {\n              const ep = // tslint:disable-next-line: no-any\n              set.endpointCreator(options, this);\n              return Object.freeze(ep); // create new & freeze\n            } catch (e) {\n              throw new Error(util.format('Unable to load endpoint %s(\"%s\"): %s', set.api.name, version, e.message));\n            }\n          };\n        }\n\n        versionIndex[set.api.name][set.api.version] = set.endpointCreator;\n      }\n\n      return apisIndex;\n    });\n  }\n  /**\n   * Generate API file given discovery URL\n   *\n   * @param apiDiscoveryUrl URL or filename of discovery doc for API\n   * @returns A promise that resolves with a function that creates the endpoint\n   */\n\n\n  discoverAPI(apiDiscoveryUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof apiDiscoveryUrl === 'string') {\n        const parts = url.parse(apiDiscoveryUrl);\n\n        if (apiDiscoveryUrl && !parts.protocol) {\n          this.log('Reading from file ' + apiDiscoveryUrl);\n          const file = yield fsp.readFile(apiDiscoveryUrl, {\n            encoding: 'utf8'\n          });\n          return this.makeEndpoint(JSON.parse(file));\n        } else {\n          this.log('Requesting ' + apiDiscoveryUrl);\n          const res = yield this.transporter.request({\n            url: apiDiscoveryUrl\n          });\n          return this.makeEndpoint(res.data);\n        }\n      } else {\n        const options = apiDiscoveryUrl;\n        this.log('Requesting ' + options.url);\n        const url = options.url;\n        delete options.url;\n        const parameters = {\n          options: {\n            url,\n            method: 'GET'\n          },\n          requiredParams: [],\n          pathParams: [],\n          params: options,\n          context: {\n            google: {\n              _options: {}\n            },\n            _options: {}\n          }\n        };\n        const pcr = pify(apirequest_1.createAPIRequest);\n        const res = yield pcr(parameters);\n        return this.makeEndpoint(res.data);\n      }\n    });\n  }\n\n}\n\nexports.Discovery = Discovery;","map":null,"metadata":{},"sourceType":"script"}