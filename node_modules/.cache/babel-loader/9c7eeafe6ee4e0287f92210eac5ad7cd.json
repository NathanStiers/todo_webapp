{"ast":null,"code":"var fs = require('fs'),\n    EventEmitter = require('events').EventEmitter,\n    util = require('util');\n\nvar readLine = module.exports = function (file, opts) {\n  if (!(this instanceof readLine)) return new readLine(file, opts);\n  EventEmitter.call(this);\n  opts = opts || {};\n  opts.maxLineLength = opts.maxLineLength || 4096; // 4K\n\n  opts.retainBuffer = !!opts.retainBuffer; //do not convert to String prior to invoking emit 'line' event\n\n  var self = this,\n      lineBuffer = new Buffer(opts.maxLineLength),\n      lineLength = 0,\n      lineCount = 0,\n      byteCount = 0,\n      emit = function (lineCount, byteCount) {\n    try {\n      var line = lineBuffer.slice(0, lineLength);\n      self.emit('line', opts.retainBuffer ? line : line.toString(), lineCount, byteCount);\n    } catch (err) {\n      self.emit('error', err);\n    } finally {\n      lineLength = 0; // Empty buffer.\n    }\n  };\n\n  this.input = 'string' === typeof file ? fs.createReadStream(file, opts) : file;\n  this.input.on('open', function (fd) {\n    self.emit('open', fd);\n  }).on('data', function (data) {\n    for (var i = 0; i < data.length; i++) {\n      if (data[i] == 10 || data[i] == 13) {\n        // Newline char was found.\n        if (data[i] == 10) {\n          lineCount++;\n          emit(lineCount, byteCount);\n        }\n      } else {\n        lineBuffer[lineLength] = data[i]; // Buffer new line data.\n\n        lineLength++;\n      }\n\n      byteCount++;\n    }\n  }).on('error', function (err) {\n    self.emit('error', err);\n  }).on('end', function () {\n    // Emit last line if anything left over since EOF won't trigger it.\n    if (lineLength) {\n      lineCount++;\n      emit(lineCount, byteCount);\n    }\n\n    self.emit('end');\n  }).on('close', function () {\n    self.emit('close');\n  });\n};\n\nutil.inherits(readLine, EventEmitter);","map":null,"metadata":{},"sourceType":"script"}